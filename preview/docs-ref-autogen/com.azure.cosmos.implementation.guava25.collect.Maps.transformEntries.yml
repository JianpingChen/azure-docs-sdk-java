### YamlMime:JavaMember
uid: "com.azure.cosmos.implementation.guava25.collect.Maps.transformEntries*"
fullName: "com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries"
name: "<K,V1,V2>transformEntries"
nameWithType: "Maps.<K,V1,V2>transformEntries"
members:
- uid: "com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(java.util.Map<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)"
  fullName: "com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(Map<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  name: "<K,V1,V2>transformEntries(Map<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  nameWithType: "Maps.<K,V1,V2>transformEntries(Map<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  summary: "Returns a view of a map whose values are derived from the original map's entries. In contrast\n to <xref uid=\"#transformValues\" data-throw-if-not-resolved=\"false\">#transformValues</xref>, this method's entry-transformation logic may depend on the key as\n well as the value.\n\n <p>All other properties of the transformed map, such as iteration order, are left intact. For\n example, the code:\n\n <pre><code>\n Map<String, Boolean> options =\n     ImmutableMap.of(\"verbose\", true, \"sort\", false);\n EntryTransformer<String, Boolean, String> flagPrefixer =\n     new EntryTransformer<String, Boolean, String>() {\n       public String transformEntry(String key, Boolean value) {\n         return value ? key : \"no\" + key;\n       }\n     };\n Map<String, String> transformed =\n     Maps.transformEntries(options, flagPrefixer);\n System.out.println(transformed);\n </code></pre>\n\n ... prints <code>{verbose=verbose, sort=nosort}</code>.\n\n <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n removal operations, and these are reflected in the underlying map.\n\n <p>It's acceptable for the underlying map to contain null keys and null values provided that\n the transformer is capable of accepting null inputs. The transformed map might contain null\n values if the transformer sometimes gives a null result.\n\n <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n\n <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n map to be a view, but it means that the transformer will be applied many times for bulk\n operations like <xref uid=\"Map#containsValue\" data-throw-if-not-resolved=\"false\">Map#containsValue</xref> and <xref uid=\"Object#toString\" data-throw-if-not-resolved=\"false\">Object#toString</xref>. For this to perform\n well, <code>transformer</code> should be fast. To avoid lazy evaluation when the returned map\n doesn't need to be a view, copy the returned map into a new map of your choosing.\n\n <p><b>Warning:</b> This method assumes that for any instance <code>k</code> of <code>\n EntryTransformer</code> key type <code>K</code>, <code>k.equals(k2)</code> implies that <code>k2</code> is also of\n type <code>K</code>. Using an <code>EntryTransformer</code> key type for which this may not hold, such as\n <code>ArrayList</code>, may risk a <code>ClassCastException</code> when calling methods on the\n transformed map."
  parameters:
  - name: "fromMap"
    type: "<xref href=\"java.util.Map?alt=java.util.Map&text=Map\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V1?alt=V1&text=V1\" data-throw-if-not-resolved=\"False\" />&gt;"
  - name: "transformer"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer?alt=com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer&text=EntryTransformer\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"? super K?alt=? super K&text=? super K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"? super V1?alt=? super V1&text=? super V1\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V2?alt=V2&text=V2\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static Map<K,V2> <K,V1,V2>transformEntries(Map<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  returns:
    type: "<xref href=\"java.util.Map?alt=java.util.Map&text=Map\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V2?alt=V2&text=V2\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(java.util.NavigableMap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)"
  fullName: "com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(NavigableMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  name: "<K,V1,V2>transformEntries(NavigableMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  nameWithType: "Maps.<K,V1,V2>transformEntries(NavigableMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  summary: "Returns a view of a navigable map whose values are derived from the original navigable map's\n entries. In contrast to <xref uid=\"#transformValues\" data-throw-if-not-resolved=\"false\">#transformValues</xref>, this method's entry-transformation logic may\n depend on the key as well as the value.\n\n <p>All other properties of the transformed map, such as iteration order, are left intact. For\n example, the code:\n\n <pre><code>\n NavigableMap<String, Boolean> options = Maps.newTreeMap();\n options.put(\"verbose\", false);\n options.put(\"sort\", true);\n EntryTransformer<String, Boolean, String> flagPrefixer =\n     new EntryTransformer<String, Boolean, String>() {\n       public String transformEntry(String key, Boolean value) {\n         return value ? key : (\"yes\" + key);\n       }\n     };\n NavigableMap<String, String> transformed =\n     LabsMaps.transformNavigableEntries(options, flagPrefixer);\n System.out.println(transformed);\n </code></pre>\n\n ... prints <code>{sort=yessort, verbose=verbose}</code>.\n\n <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n removal operations, and these are reflected in the underlying map.\n\n <p>It's acceptable for the underlying map to contain null keys and null values provided that\n the transformer is capable of accepting null inputs. The transformed map might contain null\n values if the transformer sometimes gives a null result.\n\n <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n\n <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n map to be a view, but it means that the transformer will be applied many times for bulk\n operations like <xref uid=\"Map#containsValue\" data-throw-if-not-resolved=\"false\">Map#containsValue</xref> and <xref uid=\"Object#toString\" data-throw-if-not-resolved=\"false\">Object#toString</xref>. For this to perform\n well, <code>transformer</code> should be fast. To avoid lazy evaluation when the returned map\n doesn't need to be a view, copy the returned map into a new map of your choosing.\n\n <p><b>Warning:</b> This method assumes that for any instance <code>k</code> of <code>\n EntryTransformer</code> key type <code>K</code>, <code>k.equals(k2)</code> implies that <code>k2</code> is also of\n type <code>K</code>. Using an <code>EntryTransformer</code> key type for which this may not hold, such as\n <code>ArrayList</code>, may risk a <code>ClassCastException</code> when calling methods on the\n transformed map."
  parameters:
  - name: "fromMap"
    type: "<xref href=\"java.util.NavigableMap?alt=java.util.NavigableMap&text=NavigableMap\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V1?alt=V1&text=V1\" data-throw-if-not-resolved=\"False\" />&gt;"
  - name: "transformer"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer?alt=com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer&text=EntryTransformer\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"? super K?alt=? super K&text=? super K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"? super V1?alt=? super V1&text=? super V1\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V2?alt=V2&text=V2\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static NavigableMap<K,V2> <K,V1,V2>transformEntries(NavigableMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  returns:
    type: "<xref href=\"java.util.NavigableMap?alt=java.util.NavigableMap&text=NavigableMap\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V2?alt=V2&text=V2\" data-throw-if-not-resolved=\"False\" />&gt;"
- uid: "com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(java.util.SortedMap<K,V1>,com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer<? super K,? super V1,V2>)"
  fullName: "com.azure.cosmos.implementation.guava25.collect.Maps.<K,V1,V2>transformEntries(SortedMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  name: "<K,V1,V2>transformEntries(SortedMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  nameWithType: "Maps.<K,V1,V2>transformEntries(SortedMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  summary: "Returns a view of a sorted map whose values are derived from the original sorted map's entries.\n In contrast to <xref uid=\"#transformValues\" data-throw-if-not-resolved=\"false\">#transformValues</xref>, this method's entry-transformation logic may depend on\n the key as well as the value.\n\n <p>All other properties of the transformed map, such as iteration order, are left intact. For\n example, the code:\n\n <pre><code>\n Map<String, Boolean> options =\n     ImmutableSortedMap.of(\"verbose\", true, \"sort\", false);\n EntryTransformer<String, Boolean, String> flagPrefixer =\n     new EntryTransformer<String, Boolean, String>() {\n       public String transformEntry(String key, Boolean value) {\n         return value ? key : \"yes\" + key;\n       }\n     };\n SortedMap<String, String> transformed =\n     Maps.transformEntries(options, flagPrefixer);\n System.out.println(transformed);\n </code></pre>\n\n ... prints <code>{sort=yessort, verbose=verbose}</code>.\n\n <p>Changes in the underlying map are reflected in this view. Conversely, this view supports\n removal operations, and these are reflected in the underlying map.\n\n <p>It's acceptable for the underlying map to contain null keys and null values provided that\n the transformer is capable of accepting null inputs. The transformed map might contain null\n values if the transformer sometimes gives a null result.\n\n <p>The returned map is not thread-safe or serializable, even if the underlying map is.\n\n <p>The transformer is applied lazily, invoked when needed. This is necessary for the returned\n map to be a view, but it means that the transformer will be applied many times for bulk\n operations like <xref uid=\"Map#containsValue\" data-throw-if-not-resolved=\"false\">Map#containsValue</xref> and <xref uid=\"Object#toString\" data-throw-if-not-resolved=\"false\">Object#toString</xref>. For this to perform\n well, <code>transformer</code> should be fast. To avoid lazy evaluation when the returned map\n doesn't need to be a view, copy the returned map into a new map of your choosing.\n\n <p><b>Warning:</b> This method assumes that for any instance <code>k</code> of <code>\n EntryTransformer</code> key type <code>K</code>, <code>k.equals(k2)</code> implies that <code>k2</code> is also of\n type <code>K</code>. Using an <code>EntryTransformer</code> key type for which this may not hold, such as\n <code>ArrayList</code>, may risk a <code>ClassCastException</code> when calling methods on the\n transformed map."
  parameters:
  - name: "fromMap"
    type: "<xref href=\"java.util.SortedMap?alt=java.util.SortedMap&text=SortedMap\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V1?alt=V1&text=V1\" data-throw-if-not-resolved=\"False\" />&gt;"
  - name: "transformer"
    type: "<xref href=\"com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer?alt=com.azure.cosmos.implementation.guava25.collect.Maps.EntryTransformer&text=EntryTransformer\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"? super K?alt=? super K&text=? super K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"? super V1?alt=? super V1&text=? super V1\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V2?alt=V2&text=V2\" data-throw-if-not-resolved=\"False\" />&gt;"
  syntax: "public static SortedMap<K,V2> <K,V1,V2>transformEntries(SortedMap<K,V1> fromMap, Maps.EntryTransformer<? super K,? super V1,V2> transformer)"
  returns:
    type: "<xref href=\"java.util.SortedMap?alt=java.util.SortedMap&text=SortedMap\" data-throw-if-not-resolved=\"False\" />&lt;<xref href=\"K?alt=K&text=K\" data-throw-if-not-resolved=\"False\" />,<xref href=\"V2?alt=V2&text=V2\" data-throw-if-not-resolved=\"False\" />&gt;"
type: "method"
metadata: {}
package: "com.azure.cosmos.implementation.guava25.collect"
artifact: com.azure:azure-cosmos:4.3.2-beta.2
